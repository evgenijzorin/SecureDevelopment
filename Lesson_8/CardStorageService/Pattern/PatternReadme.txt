~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Паттерны	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

-Структурные-
1. Паттерн Адаптер. Предназначен для организации использования функций объекта, недоступного для модификации, 
	через специально созданный интерфейс (или клас).
	В примере для того чтобы использовать метод Request класса MyClient принимающего объект Target, перадав ему объект SpecificTarget,
	Мы создаем объект обертку Adapter унаследованный от Target и переопределяем в нем метод Request вызывая в нем SpecificRequest у объекта specificRequest
	создав его дополнительным полем.

2. Паттерн фасад. Facade структурный шаблон проектирования, позволяющий скрыть сложность системы путём сведения всех возможных внешних вызовов к одному объекту,
	делегирующему их соответствующим объектам системы. В примере создаем класс Fasad, в котором объединяем множество классов и создем соответствующие методы. 
	Это объединения множества сущьностей в суперкласс, который выполняет всю необходимую функциональность этих методов.

3. Паттерн декоратор.
	Декоратор (англ. Decorator) — структурный шаблон проектирования, предназначенный для динамического подключения дополнительного поведения
	к объекту. Шаблон Декоратор предоставляет гибкую альтернативу практике создания подклассов с целью расширения функциональности.
    В примере создается базовый абстрактный класс BaseComponent. От этого класса создаются классы компоненты WorkComponent1 и WorkComponent2 (их может быть 
	сколь угодно), в которых различная реализация метода DoWork(). Так же от этого класса наследуется класс декоратор WorkDecoratorComponent, который содержет 
	в себе поле baseComponent, которое определяет компонент реализующий в этом классе метод DoWork(). От этого класса можно наследовать другие классы которые
	реализуют метод DoWork(), с помощью компонента который им передают
	методом SetComponent (BaseComponent baseComponent). Таким образом можно изменять функционал объектов, передавая им различные компоненты.

	-Пораждающие-
1. Паттерн Singleton.  порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную 
	точку доступа к этому экземпляру.
	В примере представлен singleToneLazy.

2. Паттерн Строитель (Builder)  порождающий шаблон проектирования предоставляет способ создания составного объекта.
	Для того чтобы создать массивный составной объект у которого очень много полей и многие из них нужно получить в результате дополнительных вычислений с передачей 
	множества параметров. 
	Чтобы создать этот объект создаем класс строитель этого объекта. У строителя имеется поле хранящее этот целевой объект; метод Create() создающий целевой объект; 
	методы назначения полей целевого объекта
	метод Build() возвращающий целевой объект;  

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
FluentValidation	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	

1. Устанавливаем: 
	пакет FluentValidation.AspNetCore - пакет для построения строго-типизированных правил валидации.
	https://docs.fluentvalidation.net - информация.
	
2. Создаем валидаторы для данных (классы проверяющие данные) эти классы создаются наследованием от AbstractValidator<T> пространства имен using FluentValidation;
	В этом классе с помощью метода RuleFor можно устанавливать правила валидации на класс переданный в AbstractValidator в качестве <T> 
	Например:		           
	RuleFor(x => x.Password)
            .NotNull()
            .Length(5, 50);			
	Эта натация называется Текучий интерфейс (англ. fluent interface — в значении «плавный» или «гладкий» «интерфейс»). В разработке программного обеспечения — способ 
	реализации	объектно-ориентированного API, нацеленный на повышение читабельности исходного кода программы. Текучий интерфейс хорош тем, что упрощается множественный 
	вызов методов одного объекта. Обычно это реализуется использованием цепочки методов, передающих контекст вызова следующему звену. 
	
3. Чтобы добавить сервис описываем его в файле Startup, в классе ConfigureServices.
	добавляем using FluentValidation;
	services.AddScoped<IValidator<AuthenticationRequest>, AuthenticationRequestValidator>();
	Далее подключаем сервис к кнтроллеру:
	private readonly IAuthenticateService _authenticateService;

4. Для валидации есть возможность проводить её в автоматическом режиме. Но этот вариант нерекомендуется из-за нестабильной работы в многопоточных методах. 
	По этому предпочтителен ручной режим. Для валидации испльзуем метод .Validate(authenticationRequest). Возвращаемое значение ValidationResult - класс описывающий 
	результат валидации. 
		
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Технология Automapping	~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Мапирование (англ. data mapping, иногда маппинг, маппирование, мэппинг, но не путать с маппингом игровых уровней) 
— определение соответствия данных между потенциально различными семантиками одного объекта или разных объектов. https://docs.automapper.org/en/latest/Getting-started.html

1. Устанавливаем: 
	пакет AutoMapper 
	пакет AutoMapper.Extensions.Microsoft.Depende

2. Создаем папку Mappings. Создаем класс MappingProfile унаследованный от Profile, добавляем пространство имен AutoMapper. MappingProfile содержит конфигурации маппинга, 
	заключающиеся в создании специальных методов CreateMap<T1, T2>. Это сопоставление полей одного класса другому.	

    public class MappingProfile : Profile
    {
        public MappingProfile()
        {
            // Создать конфигурацию маппинга. То есть автоматическое создание объектов из других объектов, сопоставляя их поля.
            CreateMap<Card, CardDto>();
            CreateMap<CreateCardRequest, Card>();
        }
            
    }

	3. В  добавляем новый сервис в файл startup
			using AutoMapper;
	        // Добавить конфигурации маппинга
            var mapperConfiguration = new MapperConfiguration(mp => mp.AddProfile(new MappingProfile()));
            var mapper = mapperConfiguration.CreateMapper();
            services.AddSingleton(mapper); // добавить маппер
		Добавляем сервис в контроллер:
			using AutoMapper;
			// Добавить сервис маппера
			private readonly IMapper _mapper;

	4. Теперь можно применять маппер для создания одних объектов из других, со сходными свойствами. Маппер автоматически сопоставляет поля объекта (T1) с полями класса (T2) 
	   и создает на этой основе новый объект (T2)
	   Примеры:					
			// Следующий синтаксис создает List<CardDto> из IList cards
            CardsDto = _mapper.Map<List<CardDto>>(cards)
			// Следующий синтаксис создает объект Card из объекта CreateCardRequest request
			var cardId = _cardRepositoryService.Create(_mapper.Map<Card>(request));
		


	 
    



	

